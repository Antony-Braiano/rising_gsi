From c0d4a977cd4041fba76c4b6e218ba67bb92f4db9 Mon Sep 17 00:00:00 2001
From: naz664 <nazimnavas145@gmail.com>
Date: Fri, 16 Sep 2022 05:07:54 +0000
Subject: [PATCH 4/4] Changes to implement squicky-seekbar animation

---
 .../drawable/media_squiggly_progress.xml      |  17 ++
 packages/SystemUI/res/values/dimens.xml       |   4 +
 packages/SystemUI/res/values/styles.xml       |   1 +
 .../android/systemui/media/SeekBarObserver.kt |  36 ++-
 .../systemui/media/SeekBarViewModel.kt        |  10 +-
 .../systemui/media/SquigglyProgress.kt        | 233 ++++++++++++++++++
 .../systemui/media/SeekBarObserverTest.kt     |  65 ++++-
 .../systemui/media/SquigglyProgressTest.kt    | 112 +++++++++
 8 files changed, 460 insertions(+), 18 deletions(-)
 create mode 100644 packages/SystemUI/res-keyguard/drawable/media_squiggly_progress.xml
 create mode 100644 packages/SystemUI/src/com/android/systemui/media/SquigglyProgress.kt
 create mode 100644 packages/SystemUI/tests/src/com/android/systemui/media/SquigglyProgressTest.kt

diff --git a/packages/SystemUI/res-keyguard/drawable/media_squiggly_progress.xml b/packages/SystemUI/res-keyguard/drawable/media_squiggly_progress.xml
new file mode 100644
index 000000000000..f2329fe5b3fa
--- /dev/null
+++ b/packages/SystemUI/res-keyguard/drawable/media_squiggly_progress.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2022 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<com.android.systemui.media.SquigglyProgress />
diff --git a/packages/SystemUI/res/values/dimens.xml b/packages/SystemUI/res/values/dimens.xml
index df4985665193..6abe39db8a6c 100644
--- a/packages/SystemUI/res/values/dimens.xml
+++ b/packages/SystemUI/res/values/dimens.xml
@@ -970,6 +970,10 @@
     <dimen name="qs_media_enabled_seekbar_height">2dp</dimen>
     <dimen name="qs_media_enabled_seekbar_vertical_padding">28dp</dimen>
     <dimen name="qs_media_disabled_seekbar_vertical_padding">29dp</dimen>
+    <dimen name="qs_media_seekbar_progress_wavelength">20dp</dimen>
+    <dimen name="qs_media_seekbar_progress_amplitude">1.5dp</dimen>
+    <dimen name="qs_media_seekbar_progress_phase">8dp</dimen>
+    <dimen name="qs_media_seekbar_progress_stroke_width">2dp</dimen>
 
     <!-- Size of Smartspace media recommendations cards in the QSPanel carousel -->
     <dimen name="qs_aa_media_rec_album_size_collapsed">72dp</dimen>
diff --git a/packages/SystemUI/res/values/styles.xml b/packages/SystemUI/res/values/styles.xml
index ad364544118d..2d2799044a22 100644
--- a/packages/SystemUI/res/values/styles.xml
+++ b/packages/SystemUI/res/values/styles.xml
@@ -549,6 +549,7 @@
     <style name="MediaPlayer.ProgressBar" parent="@android:style/Widget.ProgressBar.Horizontal">
         <item name="android:thumbTint">?android:attr/textColorPrimary</item>
         <item name="android:thumb">@*android:drawable/seekbar_thumb_material_anim</item>
+        <item name="android:progressDrawable">@drawable/media_squiggly_progress</item>
         <item name="android:progressTint">?android:attr/textColorPrimary</item>
         <item name="android:progressBackgroundTint">?android:attr/textColorTertiary</item>
         <item name="android:clickable">true</item>
diff --git a/packages/SystemUI/src/com/android/systemui/media/SeekBarObserver.kt b/packages/SystemUI/src/com/android/systemui/media/SeekBarObserver.kt
index 33ef19ad040f..115e8012e797 100644
--- a/packages/SystemUI/src/com/android/systemui/media/SeekBarObserver.kt
+++ b/packages/SystemUI/src/com/android/systemui/media/SeekBarObserver.kt
@@ -37,25 +37,47 @@ class SeekBarObserver(private val holder: PlayerViewHolder) : Observer<SeekBarVi
     val seekBarDisabledVerticalPadding = holder.seekBar.context.resources
             .getDimensionPixelSize(R.dimen.qs_media_disabled_seekbar_vertical_padding)
 
+    init {
+        val seekBarProgressWavelength = holder.seekBar.context.resources
+                .getDimensionPixelSize(R.dimen.qs_media_seekbar_progress_wavelength).toFloat()
+        val seekBarProgressAmplitude = holder.seekBar.context.resources
+                .getDimensionPixelSize(R.dimen.qs_media_seekbar_progress_amplitude).toFloat()
+        val seekBarProgressPhase = holder.seekBar.context.resources
+                .getDimensionPixelSize(R.dimen.qs_media_seekbar_progress_phase).toFloat()
+        val seekBarProgressStrokeWidth = holder.seekBar.context.resources
+                .getDimensionPixelSize(R.dimen.qs_media_seekbar_progress_stroke_width).toFloat()
+        val progressDrawable = holder.seekBar.progressDrawable as? SquigglyProgress
+        progressDrawable?.let {
+            it.waveLength = seekBarProgressWavelength
+            it.lineAmplitude = seekBarProgressAmplitude
+            it.phaseSpeed = seekBarProgressPhase
+            it.strokeWidth = seekBarProgressStrokeWidth
+        }
+     }
+
     /** Updates seek bar views when the data model changes. */
     @UiThread
     override fun onChanged(data: SeekBarViewModel.Progress) {
+        val progressDrawable = holder.seekBar.progressDrawable as? SquigglyProgress
         if (!data.enabled) {
             if (holder.seekBar.maxHeight != seekBarDisabledHeight) {
                 holder.seekBar.maxHeight = seekBarDisabledHeight
                 setVerticalPadding(seekBarDisabledVerticalPadding)
             }
-            holder.seekBar.setEnabled(false)
-            holder.seekBar.getThumb().setAlpha(0)
-            holder.seekBar.setProgress(0)
-            holder.elapsedTimeView.setText("")
-            holder.totalTimeView.setText("")
+            holder.seekBar.isEnabled = false
+            progressDrawable?.animate = false
+            holder.seekBar.thumb.alpha = 0
+            holder.seekBar.progress = 0
+            holder.elapsedTimeView?.text = ""
+            holder.totalTimeView?.text = ""
             holder.seekBar.contentDescription = ""
             return
         }
 
-        holder.seekBar.getThumb().setAlpha(if (data.seekAvailable) 255 else 0)
-        holder.seekBar.setEnabled(data.seekAvailable)
+        holder.seekBar.thumb.alpha = if (data.seekAvailable) 255 else 0
+        holder.seekBar.isEnabled = data.seekAvailable
+        progressDrawable?.animate = data.playing && !data.scrubbing
+        progressDrawable?.transitionEnabled = !data.seekAvailable
 
         if (holder.seekBar.maxHeight != seekBarEnabledMaxHeight) {
             holder.seekBar.maxHeight = seekBarEnabledMaxHeight
diff --git a/packages/SystemUI/src/com/android/systemui/media/SeekBarViewModel.kt b/packages/SystemUI/src/com/android/systemui/media/SeekBarViewModel.kt
index 9cf9c4815b67..c1480360558e 100644
--- a/packages/SystemUI/src/com/android/systemui/media/SeekBarViewModel.kt
+++ b/packages/SystemUI/src/com/android/systemui/media/SeekBarViewModel.kt
@@ -31,6 +31,7 @@ import androidx.core.view.GestureDetectorCompat
 import androidx.lifecycle.LiveData
 import androidx.lifecycle.MutableLiveData
 import com.android.systemui.dagger.qualifiers.Background
+import com.android.systemui.statusbar.NotificationMediaManager
 import com.android.systemui.util.concurrency.RepeatableExecutor
 import javax.inject.Inject
 
@@ -73,7 +74,7 @@ private fun PlaybackState.computePosition(duration: Long): Long {
 class SeekBarViewModel @Inject constructor(
     @Background private val bgExecutor: RepeatableExecutor
 ) {
-    private var _data = Progress(false, false, null, 0)
+    private var _data = Progress(false, false, false, false, null, 0)
         set(value) {
             field = value
             _progress.postValue(value)
@@ -126,6 +127,7 @@ class SeekBarViewModel @Inject constructor(
             if (field != value) {
                 field = value
                 checkIfPollingNeeded()
+                _data = _data.copy(scrubbing = value)
             }
         }
 
@@ -192,10 +194,12 @@ class SeekBarViewModel @Inject constructor(
         val seekAvailable = ((playbackState?.actions ?: 0L) and PlaybackState.ACTION_SEEK_TO) != 0L
         val position = playbackState?.position?.toInt()
         val duration = mediaMetadata?.getLong(MediaMetadata.METADATA_KEY_DURATION)?.toInt() ?: 0
+        val playing = NotificationMediaManager
+                .isPlayingState(playbackState?.state ?: PlaybackState.STATE_NONE)
         val enabled = if (playbackState == null ||
                 playbackState?.getState() == PlaybackState.STATE_NONE ||
                 (duration <= 0)) false else true
-        _data = Progress(enabled, seekAvailable, position, duration)
+        _data = Progress(enabled, seekAvailable, playing, scrubbing, position, duration)
         checkIfPollingNeeded()
     }
 
@@ -412,6 +416,8 @@ class SeekBarViewModel @Inject constructor(
     data class Progress(
         val enabled: Boolean,
         val seekAvailable: Boolean,
+        val playing: Boolean,
+        val scrubbing: Boolean,
         val elapsedTime: Int?,
         val duration: Int
     )
diff --git a/packages/SystemUI/src/com/android/systemui/media/SquigglyProgress.kt b/packages/SystemUI/src/com/android/systemui/media/SquigglyProgress.kt
new file mode 100644
index 000000000000..1ff8a0da4a99
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/media/SquigglyProgress.kt
@@ -0,0 +1,233 @@
+package com.android.systemui.media
+
+import android.animation.Animator
+import android.animation.AnimatorListenerAdapter
+import android.animation.ValueAnimator
+import android.content.res.ColorStateList
+import android.graphics.Canvas
+import android.graphics.ColorFilter
+import android.graphics.Paint
+import android.graphics.Path
+import android.graphics.PixelFormat
+import android.graphics.drawable.Drawable
+import android.os.SystemClock
+import android.util.MathUtils.lerp
+import android.util.MathUtils.lerpInv
+import android.util.MathUtils.lerpInvSat
+import androidx.annotation.VisibleForTesting
+import com.android.systemui.animation.Interpolators
+import kotlin.math.abs
+import kotlin.math.cos
+
+private const val TAG = "Squiggly"
+
+private const val TWO_PI = (Math.PI * 2f).toFloat()
+@VisibleForTesting
+internal const val DISABLED_ALPHA = 77
+
+class SquigglyProgress : Drawable() {
+
+    private val wavePaint = Paint()
+    private val linePaint = Paint()
+    private val path = Path()
+    private var heightFraction = 0f
+    private var heightAnimator: ValueAnimator? = null
+    private var phaseOffset = 0f
+    private var lastFrameTime = -1L
+
+    /* distance over which amplitude drops to zero, measured in wavelengths */
+    private val transitionPeriods = 1.5f
+    /* wave endpoint as percentage of bar when play position is zero */
+    private val minWaveEndpoint = 0.2f
+    /* wave endpoint as percentage of bar when play position matches wave endpoint */
+    private val matchedWaveEndpoint = 0.6f
+
+    // Horizontal length of the sine wave
+    var waveLength = 0f
+    // Height of each peak of the sine wave
+    var lineAmplitude = 0f
+    // Line speed in px per second
+    var phaseSpeed = 0f
+    // Progress stroke width, both for wave and solid line
+    var strokeWidth = 0f
+        set(value) {
+            if (field == value) {
+                return
+            }
+            field = value
+            wavePaint.strokeWidth = value
+            linePaint.strokeWidth = value
+        }
+
+        var transitionEnabled = true
+        set(value) {
+            field = value
+            invalidateSelf()
+        }
+
+    init {
+        wavePaint.strokeCap = Paint.Cap.ROUND
+        linePaint.strokeCap = Paint.Cap.ROUND
+        linePaint.style = Paint.Style.STROKE
+        wavePaint.style = Paint.Style.STROKE
+        linePaint.alpha = DISABLED_ALPHA
+    }
+
+    var animate: Boolean = false
+        set(value) {
+            if (field == value) {
+                return
+            }
+            field = value
+            if (field) {
+                lastFrameTime = SystemClock.uptimeMillis()
+            }
+            heightAnimator?.cancel()
+            heightAnimator = ValueAnimator.ofFloat(heightFraction, if (animate) 1f else 0f).apply {
+                if (animate) {
+                    startDelay = 60
+                    duration = 800
+                    interpolator = Interpolators.EMPHASIZED_DECELERATE
+                } else {
+                    duration = 550
+                    interpolator = Interpolators.STANDARD_DECELERATE
+                }
+                addUpdateListener {
+                    heightFraction = it.animatedValue as Float
+                    invalidateSelf()
+                }
+                addListener(object : AnimatorListenerAdapter() {
+                    override fun onAnimationEnd(animation: Animator?) {
+                        heightAnimator = null
+                    }
+                })
+                start()
+            }
+        }
+
+    override fun draw(canvas: Canvas) {
+        if (animate) {
+            invalidateSelf()
+            val now = SystemClock.uptimeMillis()
+            phaseOffset += (now - lastFrameTime) / 1000f * phaseSpeed
+            phaseOffset %= waveLength
+            lastFrameTime = now
+        }
+
+         val progress = level / 10_000f
+        val totalProgressPx = bounds.width() * progress
+        val waveProgressPx = bounds.width() * (
+            if (!transitionEnabled || progress > matchedWaveEndpoint) progress else
+            lerp(minWaveEndpoint, matchedWaveEndpoint, lerpInv(0f, matchedWaveEndpoint, progress)))
+
+        // Build Wiggly Path
+        val waveStart = -phaseOffset
+        val waveEnd = waveProgressPx
+        val transitionLength = if (transitionEnabled) transitionPeriods * waveLength else 0.01f
+
+        // helper function, computes amplitude for wave segment
+        val computeAmplitude: (Float, Float) -> Float = { x, sign ->
+            sign * heightFraction * lineAmplitude *
+                    lerpInvSat(waveEnd, waveEnd - transitionLength, x)
+        }
+
+        var currentX = waveEnd
+        var waveSign = if (phaseOffset < waveLength / 2) 1f else -1f
+        path.rewind()
+
+        // Draw flat line from end to wave endpoint
+        path.moveTo(bounds.width().toFloat(), 0f)
+        path.lineTo(waveEnd, 0f)
+
+        // First wave has shortened wavelength
+        // approx quarter wave gets us to first wave peak
+        // shouldn't be big enough to notice it's not a sin wave
+        currentX -= phaseOffset % (waveLength / 2)
+        val controlRatio = 0.25f
+        var currentAmp = computeAmplitude(currentX, waveSign)
+        path.cubicTo(
+            waveEnd, currentAmp * controlRatio,
+            lerp(currentX, waveEnd, controlRatio), currentAmp,
+            currentX, currentAmp)
+
+        // Other waves have full wavelength
+        val dist = -1 * waveLength / 2f
+        while (currentX > waveStart) {
+            waveSign = -waveSign
+            val nextX = currentX + dist
+            val midX = currentX + dist / 2
+            val nextAmp = computeAmplitude(nextX, waveSign)
+            path.cubicTo(
+                midX, currentAmp,
+                midX, nextAmp,
+                nextX, nextAmp)
+            currentAmp = nextAmp
+            currentX = nextX
+        }
+
+        // Draw path; clip to progress position
+        canvas.save()
+        canvas.translate(bounds.left.toFloat(), bounds.centerY().toFloat())
+        canvas.clipRect(
+                0f,
+                -lineAmplitude - strokeWidth,
+                totalProgressPx,
+                lineAmplitude + strokeWidth)
+        canvas.drawPath(path, wavePaint)
+        canvas.restore()
+
+        // Draw path; clip between progression position & far edge
+        canvas.save()
+        canvas.translate(bounds.left.toFloat(), bounds.centerY().toFloat())
+        canvas.clipRect(
+                totalProgressPx,
+                -lineAmplitude - strokeWidth,
+                bounds.width().toFloat(),
+                lineAmplitude + strokeWidth)
+        canvas.drawPath(path, linePaint)
+        canvas.restore()
+
+        // Draw round line cap at the beginning of the wave
+        val startAmp = cos(abs(waveEnd - phaseOffset) / waveLength * TWO_PI)
+        canvas.drawPoint(
+                bounds.left.toFloat(),
+                bounds.centerY() + startAmp * lineAmplitude * heightFraction,
+                wavePaint)
+    }
+
+    override fun getOpacity(): Int {
+        return PixelFormat.TRANSLUCENT
+    }
+
+    override fun setColorFilter(colorFilter: ColorFilter?) {
+        wavePaint.colorFilter = colorFilter
+        linePaint.colorFilter = colorFilter
+    }
+
+    override fun setAlpha(alpha: Int) {
+        wavePaint.alpha = alpha
+        linePaint.alpha = (DISABLED_ALPHA * (alpha / 255f)).toInt()
+    }
+
+    override fun getAlpha(): Int {
+        return wavePaint.alpha
+    }
+
+    override fun setTint(tintColor: Int) {
+        wavePaint.color = tintColor
+        linePaint.color = tintColor
+    }
+
+    override fun onLevelChange(level: Int): Boolean {
+        return animate
+    }
+
+    override fun setTintList(tint: ColorStateList?) {
+        if (tint == null) {
+            return
+        }
+        wavePaint.color = tint.defaultColor
+        linePaint.color = tint.defaultColor
+    }
+}
+
diff --git a/packages/SystemUI/tests/src/com/android/systemui/media/SeekBarObserverTest.kt b/packages/SystemUI/tests/src/com/android/systemui/media/SeekBarObserverTest.kt
index e77802f8db32..d676155821fd 100644
--- a/packages/SystemUI/tests/src/com/android/systemui/media/SeekBarObserverTest.kt
+++ b/packages/SystemUI/tests/src/com/android/systemui/media/SeekBarObserverTest.kt
@@ -26,36 +26,39 @@ import com.android.systemui.R
 import com.android.systemui.SysuiTestCase
 import com.google.common.truth.Truth.assertThat
 import org.junit.Before
+import org.junit.Rule
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.mockito.Mock
-import org.mockito.Mockito.mock
+import org.mockito.Mockito.verify
+import org.mockito.junit.MockitoJUnit
 import org.mockito.Mockito.`when` as whenever
 
 @SmallTest
 @RunWith(AndroidTestingRunner::class)
 @TestableLooper.RunWithLooper
-public class SeekBarObserverTest : SysuiTestCase() {
+class SeekBarObserverTest : SysuiTestCase() {
 
     private val disabledHeight = 1
     private val enabledHeight = 2
 
     private lateinit var observer: SeekBarObserver
     @Mock private lateinit var mockHolder: PlayerViewHolder
+    @Mock private lateinit var mockSquigglyProgress: SquigglyProgress
     private lateinit var seekBarView: SeekBar
     private lateinit var elapsedTimeView: TextView
     private lateinit var totalTimeView: TextView
+    @JvmField @Rule val mockitoRule = MockitoJUnit.rule()
 
     @Before
     fun setUp() {
-        mockHolder = mock(PlayerViewHolder::class.java)
-
         context.orCreateTestableResources
             .addOverride(R.dimen.qs_media_enabled_seekbar_height, enabledHeight)
         context.orCreateTestableResources
             .addOverride(R.dimen.qs_media_disabled_seekbar_height, disabledHeight)
 
         seekBarView = SeekBar(context)
+        seekBarView.progressDrawable = mockSquigglyProgress
         elapsedTimeView = TextView(context)
         totalTimeView = TextView(context)
         whenever(mockHolder.seekBar).thenReturn(seekBarView)
@@ -69,7 +72,7 @@ public class SeekBarObserverTest : SysuiTestCase() {
     fun seekBarGone() {
         // WHEN seek bar is disabled
         val isEnabled = false
-        val data = SeekBarViewModel.Progress(isEnabled, false, null, 0)
+        val data = SeekBarViewModel.Progress(isEnabled, false, false, false, null, 0)
         observer.onChanged(data)
         // THEN seek bar shows just a thin line with no text
         assertThat(seekBarView.isEnabled()).isFalse()
@@ -84,7 +87,7 @@ public class SeekBarObserverTest : SysuiTestCase() {
     fun seekBarVisible() {
         // WHEN seek bar is enabled
         val isEnabled = true
-        val data = SeekBarViewModel.Progress(isEnabled, true, 3000, 12000)
+        val data = SeekBarViewModel.Progress(isEnabled, true, false, false, 3000, 12000)
         observer.onChanged(data)
         // THEN seek bar is visible and thick
         assertThat(seekBarView.getVisibility()).isEqualTo(View.VISIBLE)
@@ -96,7 +99,7 @@ public class SeekBarObserverTest : SysuiTestCase() {
     @Test
     fun seekBarProgress() {
         // WHEN part of the track has been played
-        val data = SeekBarViewModel.Progress(true, true, 3000, 120000)
+        val data = SeekBarViewModel.Progress(true, true, true, false, 3000, 120000)
         observer.onChanged(data)
         // THEN seek bar shows the progress
         assertThat(seekBarView.progress).isEqualTo(3000)
@@ -112,7 +115,7 @@ public class SeekBarObserverTest : SysuiTestCase() {
     fun seekBarDisabledWhenSeekNotAvailable() {
         // WHEN seek is not available
         val isSeekAvailable = false
-        val data = SeekBarViewModel.Progress(true, isSeekAvailable, 3000, 120000)
+        val data = SeekBarViewModel.Progress(true, isSeekAvailable, false, false, 3000, 120000)
         observer.onChanged(data)
         // THEN seek bar is not enabled
         assertThat(seekBarView.isEnabled()).isFalse()
@@ -122,9 +125,53 @@ public class SeekBarObserverTest : SysuiTestCase() {
     fun seekBarEnabledWhenSeekNotAvailable() {
         // WHEN seek is available
         val isSeekAvailable = true
-        val data = SeekBarViewModel.Progress(true, isSeekAvailable, 3000, 120000)
+        val data = SeekBarViewModel.Progress(true, isSeekAvailable, false, false, 3000, 120000)
         observer.onChanged(data)
         // THEN seek bar is not enabled
         assertThat(seekBarView.isEnabled()).isTrue()
     }
+
+    @Test
+    fun seekBarPlayingNotScrubbing() {
+        // WHEN playing
+        val isPlaying = true
+        val isScrubbing = false
+        val data = SeekBarViewModel.Progress(true, true, isPlaying, isScrubbing, 3000, 120000)
+        observer.onChanged(data)
+        // THEN progress drawable is animating
+        verify(mockSquigglyProgress).animate = true
+    }
+
+    @Test
+  fun seekBarNotPlayingNotScrubbing() {
+        // WHEN not playing & not scrubbing
+        val isPlaying = false
+        val isScrubbing = false
+        val data = SeekBarViewModel.Progress(true, true, isPlaying, isScrubbing, 3000, 120000)
+        observer.onChanged(data)
+        // THEN progress drawable is not animating
+        verify(mockSquigglyProgress).animate = false
+    }
+
+    @Test
+    fun seekBarPlayingScrubbing() {
+        // WHEN playing & scrubbing
+        val isPlaying = true
+        val isScrubbing = true
+        val data = SeekBarViewModel.Progress(true, true, isPlaying, isScrubbing, 3000, 120000)
+        observer.onChanged(data)
+        // THEN progress drawable is not animating
+        verify(mockSquigglyProgress).animate = false
+    }
+
+    @Test
+    fun seekBarNotPlayingScrubbing() {
+        // WHEN playing & scrubbing
+        val isPlaying = false
+        val isScrubbing = true
+        val data = SeekBarViewModel.Progress(true, true, isPlaying, isScrubbing, 3000, 120000)
+        observer.onChanged(data)
+        // THEN progress drawable is not animating
+        verify(mockSquigglyProgress).animate = false
+    }
 }
diff --git a/packages/SystemUI/tests/src/com/android/systemui/media/SquigglyProgressTest.kt b/packages/SystemUI/tests/src/com/android/systemui/media/SquigglyProgressTest.kt
new file mode 100644
index 000000000000..3a97241918ac
--- /dev/null
+++ b/packages/SystemUI/tests/src/com/android/systemui/media/SquigglyProgressTest.kt
@@ -0,0 +1,112 @@
+package com.android.systemui.media
+
+import android.graphics.Canvas
+import android.graphics.Color
+import android.graphics.LightingColorFilter
+import android.graphics.Paint
+import android.graphics.Rect
+import android.testing.AndroidTestingRunner
+import android.testing.TestableLooper
+import androidx.test.filters.SmallTest
+import com.android.systemui.SysuiTestCase
+import com.android.systemui.util.mockito.any
+import com.google.common.truth.Truth.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.ArgumentCaptor
+import org.mockito.Captor
+import org.mockito.Mock
+import org.mockito.Mockito.times
+import org.mockito.Mockito.verify
+import org.mockito.junit.MockitoJUnit
+
+@SmallTest
+@RunWith(AndroidTestingRunner::class)
+@TestableLooper.RunWithLooper
+class SquigglyProgressTest : SysuiTestCase() {
+
+    private val colorFilter = LightingColorFilter(Color.RED, Color.BLUE)
+    private val strokeWidth = 5f
+    private val alpha = 128
+    private val tint = Color.GREEN
+
+    lateinit var squigglyProgress: SquigglyProgress
+    @Mock lateinit var canvas: Canvas
+    @Captor lateinit var paintCaptor: ArgumentCaptor<Paint>
+    @JvmField @Rule val mockitoRule = MockitoJUnit.rule()
+
+    @Before
+    fun setup() {
+        squigglyProgress = SquigglyProgress()
+        squigglyProgress.waveLength = 30f
+        squigglyProgress.lineAmplitude = 10f
+        squigglyProgress.phaseSpeed = 8f
+        squigglyProgress.strokeWidth = strokeWidth
+        squigglyProgress.bounds = Rect(0, 0, 300, 30)
+    }
+
+    @Test
+    fun testDrawPathAndLine() {
+        squigglyProgress.draw(canvas)
+
+        verify(canvas, times(2)).drawPath(any(), paintCaptor.capture())
+    }
+
+    @Test
+    fun testOnLevelChanged() {
+        assertThat(squigglyProgress.setLevel(5)).isFalse()
+        squigglyProgress.animate = true
+        assertThat(squigglyProgress.setLevel(4)).isTrue()
+    }
+
+    @Test
+    fun testStrokeWidth() {
+        squigglyProgress.draw(canvas)
+
+        verify(canvas, times(2)).drawPath(any(), paintCaptor.capture())
+        val (wavePaint, linePaint) = paintCaptor.getAllValues()
+
+        assertThat(wavePaint.strokeWidth).isEqualTo(strokeWidth)
+        assertThat(linePaint.strokeWidth).isEqualTo(strokeWidth)
+    }
+
+    @Test
+    fun testAlpha() {
+        squigglyProgress.alpha = alpha
+        squigglyProgress.draw(canvas)
+
+        verify(canvas, times(2)).drawPath(any(), paintCaptor.capture())
+        val (wavePaint, linePaint) = paintCaptor.getAllValues()
+
+        assertThat(squigglyProgress.alpha).isEqualTo(alpha)
+        assertThat(wavePaint.alpha).isEqualTo(alpha)
+        assertThat(linePaint.alpha).isEqualTo((alpha / 255f * DISABLED_ALPHA).toInt())
+    }
+
+    @Test
+    fun testColorFilter() {
+        squigglyProgress.colorFilter = colorFilter
+        squigglyProgress.draw(canvas)
+
+        verify(canvas, times(2)).drawPath(any(), paintCaptor.capture())
+        val (wavePaint, linePaint) = paintCaptor.getAllValues()
+
+        assertThat(wavePaint.colorFilter).isEqualTo(colorFilter)
+        assertThat(linePaint.colorFilter).isEqualTo(colorFilter)
+    }
+
+    @Test
+    fun testTint() {
+        squigglyProgress.setTint(tint)
+        squigglyProgress.draw(canvas)
+
+        verify(canvas, times(2)).drawPath(any(), paintCaptor.capture())
+        val (wavePaint, linePaint) = paintCaptor.getAllValues()
+
+        assertThat(wavePaint.color).isEqualTo(tint)
+        assertThat(linePaint.color).isEqualTo(
+               ColorUtils.setAlphaComponent(tint, DISABLED_ALPHA))
+    }
+}
-- 
2.25.1

